---
layout: post
title: "java各类内存溢出问题发生原因分析"
date: 2017-08-28 13:52
comments: true
categories: cache
---

内存溢出问题是个老生常谈的问题，也是个常谈常新的问题，作为高级程序员如果解决不好内存溢出问题，那么在程序的健壮性上可能会出很多莫名其妙的问题。

java有很多类型的内存溢出，但是很多类型我们日常碰到的概率都很小，有些碰到的概率较大。每种溢出都有调节配置规避的方法。但是首先我们要熟悉java的内存模型和不同区域存放哪些东西，这样更有利于我们查找原因。说到传统的内存模型，有一个很经典的图片：

图1
<img src="http://my.csdn.net/uploads/201205/05/1336185361_6442.png" style="margin:0px 10px;">

此处的内存被分为堆区和perm区，堆区中又分为老年代和年轻代。还有一种逻辑概念的分区:

图2
<img src="http://www.thomasyoung.cn/media/img/002RSgYjgy70Bv9xr9Ob4&690.jpg" style="margin:0px 10px;">

图2中的方法区其实是个分区的逻辑概念，如果跟上图对应的话，它实际存在perm区中。后期perm区被废弃掉后，方法区被移到了堆中，但是在逻辑上，他们还是会作为两个概念来讨论；
程序计数器（program counter register）只占用了一块比较小的内存空间，至于小到什么程度呢，这样说吧，有时可以忽略不计的。程序计数器是每个线程私有的,这个内存区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError的情况的区域。
本地方法栈是个特殊的栈，是java调用本地native方法时创建的栈，具体可以参考此链接[http://www.cnblogs.com/wade-luffy/p/5813747.html](http://www.cnblogs.com/wade-luffy/p/5813747.html)

## 常见的几种溢出

### 堆溢出 OutOfMemoryError: Java heap space

堆溢出出现的情况是最多的，因为java堆用来存放我们的java对象的。java因为其强大的gc能力，让程序员在写代码时可以随意的创建对象而不用申请内存，自由当然是有代价的，结果就造成了堆溢出。堆溢出是如何产生的呢，我们来看jvm的内存申请过程：

1. JVM 会试图为相关Java对象在Eden中初始化一块内存区域
1. 当Eden空间足够时，内存申请结束；否则到下一步
1. JVM 试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）,释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区
1. Survivor区被用来作为Eden及OLD的中间交换区域，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区
1. 当OLD区空间不够时，JVM 会在OLD区进行完全的垃圾收集（0级）
1. 完全垃圾收集后，若Survivor及OLD区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory”错误

溢出了怎么处理呢？当然是调整堆内存参数啦。对堆内存进行管理的jvm参数有很多，我们要熟悉每个参数的含义，按照自己程序的实际需求进行调整。要记住，每个程序都有其合理的内存分配方式，没有万能的配置方式，要按照自己的需求记性调整，至于如何调整，可以参照此博客：[http://blog.csdn.net/sivyer123/article/details/17139443/](http://blog.csdn.net/sivyer123/article/details/17139443/)

### 栈内存溢出 java.lang.StackOverflowError

栈的概念更加抽象，一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。我们知道jvm的运行基础是线程，不管是一个简单的main方法还是复杂的多线程编程，每一块代码的运行都是在其线程中运行。而栈是跟线程绑定在一块的，jvm为每个线程分配一个栈，这个栈就为此线程服务。在堆栈中又以帧为单位保存线程的运行状态。比如此线程运行期间，开始执行某个方法，某个线程正在执行的方法称为此线程的当前方法，当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧，压入的这个新帧被存在栈顶成为新的当前帧。这个帧将用来保存参数,局部变量,中间计算过程和其他数据。
栈的大小当然是有大小限制的，一般情况下栈都不会很大，因为它只存放引用和基本类型变量，有时候为了实现更多的线程数甚至希望栈更小一点。碰到栈内存溢出的问题一般不多，一般会出现在递归问题上，因为每次新进一个方法都要新生成一个帧，那么递归的太深，帧数太多，肯定就会溢出了，所以有聪明人通过尾递归优化来解决这个问题。

### perm 区内存溢出 java.lang.OutOfMemoryError: PermGen space

perm区也是大家比较容易碰到的溢出问题，特别是jsp盛行的年代，我们知道jsp文件都会被编译成servlet，这个compile会产生很多的class，而且一般jsp文件还都不小，很多人喜欢把大把大把的代码全都写在jsp里面，带来的是编译过的servlet也很大。perm是永久代，很大的一部分是用来存这些class的。引入的lib过多，jsp文件过多等都会因为class过多，进而造成perm内存溢出。perm区的内存可以通过参数配置进行设置。
好消息是，perm区即将成为历史。java1.7后已移到堆中，java1.8已经将其移到了Metaspace，metaspace是在本地内存中分配空间的，只受本地内存空间限制，所以说这就很大很大啦，但是也不排除会出现metaspace溢出啦！！

###  外部内存溢出 java.lang.OutOfMemoryError: Direct buffer memory

外部内存是个只有nio场景下才会使用的内存，因为操作系统为每个进程都有内存分配的限制，jvm已经占用了进程的大多数份额的情况下，在nio中direct buffer能申请的内存就比较少了，一旦超出了限制自然就会溢出。我们有参数-XX:MaxDirectMemorySize可以扩大DirectMemory的份额，对于nio使用较多的地方，可以适当调大。并且要做好跟堆内存之间的平衡，毕竟达到进程最大可用内存，再怎么申请也是没用的。网友还有一个提示：-XX:+DisableExplicitGC会是System.gc()失效，所以不能设置此参数，在申请DirectMemory前手动gc来获取尽可能多的内存分配。

### gc开销超出限制 java.lang.OutOfMemoryError: GC overhead limit exceeded

这是Hotspot VM 1.6定义的一个策略，通过统计GC时间来预测是否要OOM了，提前抛出异常，防止OOM发生；Sun 官方对此的定义是：“并行/并发回收器在GC回收时间过长时会抛出OutOfMemroyError。过长的定义是，超过98%的时间用来做GC并且回收了不到2%的堆内存。用来避免内存过小造成应用不能正常工作。“ 这是个一个前期预警，就是提示用户我怎么gc也产生不了空闲空间供你使用啦，试了很多次都不行啦，你放弃吧！！！但是这个跟溢出其实一样的意思，我在测试的时候发现一段代码有时候报GC overhead limit exceeded的错误，有时候也可能报Java heap space溢出的错误，所以这两个错误发生的原因应该是相似的。

## 总结

溢出类型很多，一定要对症下药，不能病急乱投医。要做好代码中各个内存区的平衡，有些人看到哪缺了就拼命设到最大，这是一种没有全局考虑的思路大家不要效仿。最后祝大家写出健壮性更高的代码。